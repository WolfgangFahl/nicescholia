{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nicescholia API Documentation","text":""},{"location":"#nscholia.cmd","title":"<code>cmd</code>","text":"<p>Command line entry point</p>"},{"location":"#nscholia.cmd.ScholiaCmd","title":"<code>ScholiaCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>Command Line Interface</p> Source code in <code>nscholia/cmd.py</code> <pre><code>class ScholiaCmd(WebserverCmd):\n    \"\"\"\n    Command Line Interface\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        parser = super().getArgParser(description, version_msg)\n        return parser\n</code></pre>"},{"location":"#nscholia.dashboard","title":"<code>dashboard</code>","text":""},{"location":"#nscholia.dashboard.Dashboard","title":"<code>Dashboard</code>","text":"<p>UI for monitoring endpoints using ListOfDictsGrid.</p> Source code in <code>nscholia/dashboard.py</code> <pre><code>class Dashboard:\n    \"\"\"\n    UI for monitoring endpoints using ListOfDictsGrid.\n    \"\"\"\n\n    def __init__(self, solution):\n        self.solution = solution\n        self.webserver = solution.webserver\n        self.grid = None  # Will hold the ListOfDictsGrid instance\n\n        # Initialize the endpoints provider\n        self.endpoints_provider = Endpoints()\n\n    async def check_all(self):\n        \"\"\"Run checks for all endpoints in the grid\"\"\"\n        if not self.grid:\n            return\n\n        ui.notify(\"Checking endpoints...\")\n\n        # Access the List of Dicts (LOD) directly from the wrapper\n        rows = self.grid.lod\n\n        for row in rows:\n            # Visual update for checking state\n            row[\"status\"] = \"Checking...\"\n            row[\"color\"] = \"#f0f0f0\"  # Light gray\n            row[\"triples\"] = 0\n            row[\"timestamp\"] = \"\"\n\n            # Update the grid view to show 'Checking...' state immediately\n            self.grid.update()\n\n            # Async check\n            try:\n                url = row[\"url\"]\n                # First check if endpoint is online\n                result = await Monitor.check(url)\n\n                # Update basic availability result\n                if result.is_online:\n                    row[\"status\"] = f\"Online ({result.status_code})\"\n                    row[\"latency\"] = result.latency\n                    row[\"color\"] = \"#d1fae5\"  # light green\n\n                    # Now get update state information (triples &amp; timestamp)\n                    ep_key = row[\"endpoint_key\"]\n                    endpoints_data = self.endpoints_provider.get_endpoints()\n\n                    if ep_key in endpoints_data:\n                        ep = endpoints_data[ep_key]\n                        # Run update state query in executor to avoid blocking\n                        update_state = await asyncio.get_event_loop().run_in_executor(\n                            None, UpdateState.from_endpoint, self.endpoints_provider, ep\n                        )\n\n                        if update_state.success:\n                            row[\"triples\"] = update_state.triples or 0\n                            row[\"timestamp\"] = update_state.timestamp or \"\"\n                        else:\n                            row[\"triples\"] = 0\n                            row[\"timestamp\"] = update_state.error or \"N/A\"\n                            # Optionally adjust status if update query failed\n                            if update_state.error:\n                                row[\n                                    \"status\"\n                                ] += f\" (Update query: {update_state.error})\"\n                else:\n                    row[\"status\"] = result.error or f\"Error {result.status_code}\"\n                    row[\"latency\"] = 0\n                    row[\"triples\"] = 0\n                    row[\"timestamp\"] = \"\"\n                    row[\"color\"] = \"#fee2e2\"  # light red\n\n            except Exception as ex:\n                row[\"status\"] = str(ex)\n                row[\"latency\"] = 0\n                row[\"triples\"] = 0\n                row[\"timestamp\"] = \"\"\n                row[\"color\"] = \"#fee2e2\"\n\n        # Final update to show results\n        self.grid.update()\n        ui.notify(\"Status check complete\")\n\n    def setup_ui(self):\n        \"\"\"\n        Render the dashboard\n        \"\"\"\n        with ui.row().classes(\"w-full items-center mb-4\"):\n            ui.label(\"Endpoint Monitor\").classes(\"text-2xl font-bold\")\n            ui.button(\"Refresh\", icon=\"refresh\", on_click=self.check_all)\n\n        # 1. Fetch data\n        endpoints_data = self.endpoints_provider.get_endpoints()\n\n        rows = []\n        for key, ep in endpoints_data.items():\n            # Prefer checking the website URL over the SPARQL endpoint\n            check_url = getattr(ep, \"website\", None)\n            if not check_url:\n                check_url = getattr(ep, \"endpoint\", getattr(ep, \"url\", \"\"))\n\n            ep_url = getattr(ep, \"endpoint\", getattr(ep, \"url\", \"\"))\n            ep_name = getattr(ep, \"name\", key)\n            ep_group = getattr(ep, \"group\", \"General\")\n\n            link_html = Link.create(\n                check_url if hasattr(ep, \"website\") else ep_url, \"Link\"\n            )\n\n            rows.append(\n                {\n                    \"group\": ep_group,\n                    \"name\": ep_name,\n                    \"url\": check_url,  # URL to check for availability\n                    \"endpoint_url\": ep_url,  # Original SPARQL endpoint\n                    \"endpoint_key\": key,  # Store the key for later lookup\n                    \"link\": link_html,\n                    \"status\": \"Pending\",\n                    \"latency\": 0.0,\n                    \"triples\": 0,\n                    \"timestamp\": \"\",\n                    \"color\": \"#ffffff\",\n                }\n            )\n\n        column_defs = [\n            {\"headerName\": \"Group\", \"field\": \"group\", \"rowGroup\": True, \"hide\": True},\n            {\n                \"headerName\": \"Service\",\n                \"field\": \"name\",\n                \"sortable\": True,\n                \"filter\": True,\n                \"flex\": 2,\n            },\n            {\n                \"headerName\": \"URL\",\n                \"field\": \"link\",\n                \"width\": 70,\n            },\n            {\n                \"headerName\": \"Status\",\n                \"field\": \"status\",\n                \"sortable\": True,\n                \"flex\": 2,\n            },\n            {\n                \"headerName\": \"Latency (s)\",\n                \"field\": \"latency\",\n                \"sortable\": True,\n                \"width\": 120,\n                \"type\": \"numericColumn\",\n                \"valueFormatter\": \"params.value ? params.value.toFixed(3) : '0.000'\",\n            },\n            {\n                \"headerName\": \"Triples\",\n                \"field\": \"triples\",\n                \"sortable\": True,\n                \"width\": 130,\n                \"type\": \"numericColumn\",\n                \"valueFormatter\": \"params.value ? params.value.toLocaleString() : '0'\",\n            },\n            {\n                \"headerName\": \"Last Update\",\n                \"field\": \"timestamp\",\n                \"sortable\": True,\n                \"width\": 200,\n            },\n        ]\n\n        grid_options = {\n            \"rowSelection\": \"single\",\n            \"animateRows\": True,\n            \":getRowStyle\": \"\"\"(params) =&gt; {\n                return { background: params.data.color };\n            }\"\"\",\n        }\n\n        config = GridConfig(\n            column_defs=column_defs,\n            key_col=\"url\",\n            options=grid_options,\n            html_columns=[2],\n            auto_size_columns=True,\n            theme=\"balham\",\n        )\n\n        self.grid = ListOfDictsGrid(lod=rows, config=config)\n        ui.timer(0.5, self.check_all, once=True)\n</code></pre>"},{"location":"#nscholia.dashboard.Dashboard.check_all","title":"<code>check_all()</code>  <code>async</code>","text":"<p>Run checks for all endpoints in the grid</p> Source code in <code>nscholia/dashboard.py</code> <pre><code>async def check_all(self):\n    \"\"\"Run checks for all endpoints in the grid\"\"\"\n    if not self.grid:\n        return\n\n    ui.notify(\"Checking endpoints...\")\n\n    # Access the List of Dicts (LOD) directly from the wrapper\n    rows = self.grid.lod\n\n    for row in rows:\n        # Visual update for checking state\n        row[\"status\"] = \"Checking...\"\n        row[\"color\"] = \"#f0f0f0\"  # Light gray\n        row[\"triples\"] = 0\n        row[\"timestamp\"] = \"\"\n\n        # Update the grid view to show 'Checking...' state immediately\n        self.grid.update()\n\n        # Async check\n        try:\n            url = row[\"url\"]\n            # First check if endpoint is online\n            result = await Monitor.check(url)\n\n            # Update basic availability result\n            if result.is_online:\n                row[\"status\"] = f\"Online ({result.status_code})\"\n                row[\"latency\"] = result.latency\n                row[\"color\"] = \"#d1fae5\"  # light green\n\n                # Now get update state information (triples &amp; timestamp)\n                ep_key = row[\"endpoint_key\"]\n                endpoints_data = self.endpoints_provider.get_endpoints()\n\n                if ep_key in endpoints_data:\n                    ep = endpoints_data[ep_key]\n                    # Run update state query in executor to avoid blocking\n                    update_state = await asyncio.get_event_loop().run_in_executor(\n                        None, UpdateState.from_endpoint, self.endpoints_provider, ep\n                    )\n\n                    if update_state.success:\n                        row[\"triples\"] = update_state.triples or 0\n                        row[\"timestamp\"] = update_state.timestamp or \"\"\n                    else:\n                        row[\"triples\"] = 0\n                        row[\"timestamp\"] = update_state.error or \"N/A\"\n                        # Optionally adjust status if update query failed\n                        if update_state.error:\n                            row[\n                                \"status\"\n                            ] += f\" (Update query: {update_state.error})\"\n            else:\n                row[\"status\"] = result.error or f\"Error {result.status_code}\"\n                row[\"latency\"] = 0\n                row[\"triples\"] = 0\n                row[\"timestamp\"] = \"\"\n                row[\"color\"] = \"#fee2e2\"  # light red\n\n        except Exception as ex:\n            row[\"status\"] = str(ex)\n            row[\"latency\"] = 0\n            row[\"triples\"] = 0\n            row[\"timestamp\"] = \"\"\n            row[\"color\"] = \"#fee2e2\"\n\n    # Final update to show results\n    self.grid.update()\n    ui.notify(\"Status check complete\")\n</code></pre>"},{"location":"#nscholia.dashboard.Dashboard.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Render the dashboard</p> Source code in <code>nscholia/dashboard.py</code> <pre><code>def setup_ui(self):\n    \"\"\"\n    Render the dashboard\n    \"\"\"\n    with ui.row().classes(\"w-full items-center mb-4\"):\n        ui.label(\"Endpoint Monitor\").classes(\"text-2xl font-bold\")\n        ui.button(\"Refresh\", icon=\"refresh\", on_click=self.check_all)\n\n    # 1. Fetch data\n    endpoints_data = self.endpoints_provider.get_endpoints()\n\n    rows = []\n    for key, ep in endpoints_data.items():\n        # Prefer checking the website URL over the SPARQL endpoint\n        check_url = getattr(ep, \"website\", None)\n        if not check_url:\n            check_url = getattr(ep, \"endpoint\", getattr(ep, \"url\", \"\"))\n\n        ep_url = getattr(ep, \"endpoint\", getattr(ep, \"url\", \"\"))\n        ep_name = getattr(ep, \"name\", key)\n        ep_group = getattr(ep, \"group\", \"General\")\n\n        link_html = Link.create(\n            check_url if hasattr(ep, \"website\") else ep_url, \"Link\"\n        )\n\n        rows.append(\n            {\n                \"group\": ep_group,\n                \"name\": ep_name,\n                \"url\": check_url,  # URL to check for availability\n                \"endpoint_url\": ep_url,  # Original SPARQL endpoint\n                \"endpoint_key\": key,  # Store the key for later lookup\n                \"link\": link_html,\n                \"status\": \"Pending\",\n                \"latency\": 0.0,\n                \"triples\": 0,\n                \"timestamp\": \"\",\n                \"color\": \"#ffffff\",\n            }\n        )\n\n    column_defs = [\n        {\"headerName\": \"Group\", \"field\": \"group\", \"rowGroup\": True, \"hide\": True},\n        {\n            \"headerName\": \"Service\",\n            \"field\": \"name\",\n            \"sortable\": True,\n            \"filter\": True,\n            \"flex\": 2,\n        },\n        {\n            \"headerName\": \"URL\",\n            \"field\": \"link\",\n            \"width\": 70,\n        },\n        {\n            \"headerName\": \"Status\",\n            \"field\": \"status\",\n            \"sortable\": True,\n            \"flex\": 2,\n        },\n        {\n            \"headerName\": \"Latency (s)\",\n            \"field\": \"latency\",\n            \"sortable\": True,\n            \"width\": 120,\n            \"type\": \"numericColumn\",\n            \"valueFormatter\": \"params.value ? params.value.toFixed(3) : '0.000'\",\n        },\n        {\n            \"headerName\": \"Triples\",\n            \"field\": \"triples\",\n            \"sortable\": True,\n            \"width\": 130,\n            \"type\": \"numericColumn\",\n            \"valueFormatter\": \"params.value ? params.value.toLocaleString() : '0'\",\n        },\n        {\n            \"headerName\": \"Last Update\",\n            \"field\": \"timestamp\",\n            \"sortable\": True,\n            \"width\": 200,\n        },\n    ]\n\n    grid_options = {\n        \"rowSelection\": \"single\",\n        \"animateRows\": True,\n        \":getRowStyle\": \"\"\"(params) =&gt; {\n            return { background: params.data.color };\n        }\"\"\",\n    }\n\n    config = GridConfig(\n        column_defs=column_defs,\n        key_col=\"url\",\n        options=grid_options,\n        html_columns=[2],\n        auto_size_columns=True,\n        theme=\"balham\",\n    )\n\n    self.grid = ListOfDictsGrid(lod=rows, config=config)\n    ui.timer(0.5, self.check_all, once=True)\n</code></pre>"},{"location":"#nscholia.endpoints","title":"<code>endpoints</code>","text":"<p>created 2025-12-17 author wf</p>"},{"location":"#nscholia.endpoints.Endpoints","title":"<code>Endpoints</code>","text":"<p>endpoints access</p> Source code in <code>nscholia/endpoints.py</code> <pre><code>class Endpoints:\n    \"\"\"\n    endpoints access\n    \"\"\"\n\n    def __init__(self):\n        self.nqm = NamedQueryManager.from_samples()\n        # Initialize QueryManager with the specific YAML path for dashboard queries\n        yaml_path = (\n            Path(__file__).parent.parent\n            / \"nscholia_examples\"\n            / \"dashboard_queries.yaml\"\n        )\n        if not os.path.exists(yaml_path):\n            raise FileNotFoundError(f\"Query YAML file not found: {yaml_path}\")\n        self.qm = QueryManager(\n            lang=\"sparql\", queriesPath=yaml_path, with_default=False, debug=False\n        )\n\n    def get_endpoints(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        list all endpoints\n        \"\"\"\n        endpoints = self.nqm.endpoints\n        return endpoints\n\n    def runQuery(self, query: Query) -&gt; Optional[List[Dict[str, Any]]]:\n        \"\"\"\n        Run a SPARQL query and return results as list of dicts\n\n        Args:\n            query: Query object to execute\n\n        Returns:\n            List of dictionaries containing query results, or None if error\n        \"\"\"\n        endpoint = SPARQL(query.endpoint)\n        if query.params.has_params:\n            query.apply_default_params()\n        qlod = endpoint.queryAsListOfDicts(\n            query.query, param_dict=query.params.params_dict\n        )\n        return qlod\n\n    def update_state_query_for_endpoint(self, ep: Endpoint) -&gt; Query:\n        \"\"\"\n        get the update state query for the given endpoint\n        \"\"\"\n        query = None\n        if ep.database == \"blazegraph\" and \"wikidata\" in ep.name.lower():\n            query_name = \"WikidataUpdateState\"\n        elif ep.database == \"qlever\":\n            query_name = \"QLeverUpdateState\"\n        else:\n            query_name = \"TripleCount\"\n        if query_name in self.qm.queriesByName:\n            query = self.qm.queriesByName.get(query_name)\n            query.endpoint = ep.endpoint\n        return query\n</code></pre>"},{"location":"#nscholia.endpoints.Endpoints.get_endpoints","title":"<code>get_endpoints()</code>","text":"<p>list all endpoints</p> Source code in <code>nscholia/endpoints.py</code> <pre><code>def get_endpoints(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    list all endpoints\n    \"\"\"\n    endpoints = self.nqm.endpoints\n    return endpoints\n</code></pre>"},{"location":"#nscholia.endpoints.Endpoints.runQuery","title":"<code>runQuery(query)</code>","text":"<p>Run a SPARQL query and return results as list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>Query</code> <p>Query object to execute</p> required <p>Returns:</p> Type Description <code>Optional[List[Dict[str, Any]]]</code> <p>List of dictionaries containing query results, or None if error</p> Source code in <code>nscholia/endpoints.py</code> <pre><code>def runQuery(self, query: Query) -&gt; Optional[List[Dict[str, Any]]]:\n    \"\"\"\n    Run a SPARQL query and return results as list of dicts\n\n    Args:\n        query: Query object to execute\n\n    Returns:\n        List of dictionaries containing query results, or None if error\n    \"\"\"\n    endpoint = SPARQL(query.endpoint)\n    if query.params.has_params:\n        query.apply_default_params()\n    qlod = endpoint.queryAsListOfDicts(\n        query.query, param_dict=query.params.params_dict\n    )\n    return qlod\n</code></pre>"},{"location":"#nscholia.endpoints.Endpoints.update_state_query_for_endpoint","title":"<code>update_state_query_for_endpoint(ep)</code>","text":"<p>get the update state query for the given endpoint</p> Source code in <code>nscholia/endpoints.py</code> <pre><code>def update_state_query_for_endpoint(self, ep: Endpoint) -&gt; Query:\n    \"\"\"\n    get the update state query for the given endpoint\n    \"\"\"\n    query = None\n    if ep.database == \"blazegraph\" and \"wikidata\" in ep.name.lower():\n        query_name = \"WikidataUpdateState\"\n    elif ep.database == \"qlever\":\n        query_name = \"QLeverUpdateState\"\n    else:\n        query_name = \"TripleCount\"\n    if query_name in self.qm.queriesByName:\n        query = self.qm.queriesByName.get(query_name)\n        query.endpoint = ep.endpoint\n    return query\n</code></pre>"},{"location":"#nscholia.endpoints.UpdateState","title":"<code>UpdateState</code>  <code>dataclass</code>","text":"<p>the update state of and endpoint</p> Source code in <code>nscholia/endpoints.py</code> <pre><code>@dataclass\nclass UpdateState:\n    \"\"\"\n    the update state of and endpoint\n    \"\"\"\n\n    endpoint_name: str\n    triples: Optional[int] = None\n    timestamp: Optional[str] = None\n    success: bool = False\n    error: Optional[str] = None\n\n    @classmethod\n    def from_endpoint(cls, em: Endpoints, ep: Endpoint):\n        update_state = cls(triples=0, timestamp=ep.data_seeded, endpoint_name=ep.name)\n        try:\n            query = em.update_state_query_for_endpoint(ep)\n            qlod = em.runQuery(query)\n            success = qlod and len(qlod) &gt; 0\n            if success:\n                update_state.success = True\n                record = qlod[0]\n                if \"tripleCount\" in record:\n                    update_state.triples = int(record.get(\"tripleCount\"))\n                for var_name in [\"timestamp\", \"updates_complete_until\"]:\n                    if var_name in record:\n                        timestamp = record.get(var_name)\n                        if isinstance(timestamp, datetime):\n                            timestamp = timestamp.isoformat()\n                        update_state.timestamp = timestamp\n                        break\n            else:\n                update_state.error = \"query failed\"\n        except Exception as ex:\n            update_state.error = str(ex)\n        return update_state\n</code></pre>"},{"location":"#nscholia.monitor","title":"<code>monitor</code>","text":"<p>Availability monitoring logic</p>"},{"location":"#nscholia.monitor.Monitor","title":"<code>Monitor</code>","text":"<p>Checks endpoint availability</p> Source code in <code>nscholia/monitor.py</code> <pre><code>class Monitor:\n    \"\"\"\n    Checks endpoint availability\n    \"\"\"\n\n    # Default User-Agent to avoid being blocked by servers\n    DEFAULT_USER_AGENT = (\n        \"nscholia-monitor/1.0 (https://github.com/WolfgangFahl/nscholia)\"\n    )\n\n    @staticmethod\n    async def check(\n        url: str, timeout: float = 5.0, user_agent: str = None\n    ) -&gt; StatusResult:\n        \"\"\"\n        Check if an endpoint is available.\n\n        Args:\n            url: URL to check\n            timeout: Request timeout in seconds\n            user_agent: Custom user agent string\n        \"\"\"\n        if user_agent is None:\n            user_agent = Monitor.DEFAULT_USER_AGENT\n\n        headers = {\"User-Agent\": user_agent}\n        start_time = time.time()\n\n        try:\n            async with httpx.AsyncClient(follow_redirects=True) as client:\n                response = await client.get(url, headers=headers, timeout=timeout)\n                duration = time.time() - start_time\n                return StatusResult(\n                    endpoint_name=\"\",  # Filled by caller\n                    url=url,\n                    status_code=response.status_code,\n                    latency=round(duration, 3),\n                )\n        except httpx.TimeoutException:\n            return StatusResult(endpoint_name=\"\", url=url, error=\"Timeout\")\n        except Exception as e:\n            return StatusResult(endpoint_name=\"\", url=url, error=str(e))\n</code></pre>"},{"location":"#nscholia.monitor.Monitor.check","title":"<code>check(url, timeout=5.0, user_agent=None)</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Check if an endpoint is available.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to check</p> required <code>timeout</code> <code>float</code> <p>Request timeout in seconds</p> <code>5.0</code> <code>user_agent</code> <code>str</code> <p>Custom user agent string</p> <code>None</code> Source code in <code>nscholia/monitor.py</code> <pre><code>@staticmethod\nasync def check(\n    url: str, timeout: float = 5.0, user_agent: str = None\n) -&gt; StatusResult:\n    \"\"\"\n    Check if an endpoint is available.\n\n    Args:\n        url: URL to check\n        timeout: Request timeout in seconds\n        user_agent: Custom user agent string\n    \"\"\"\n    if user_agent is None:\n        user_agent = Monitor.DEFAULT_USER_AGENT\n\n    headers = {\"User-Agent\": user_agent}\n    start_time = time.time()\n\n    try:\n        async with httpx.AsyncClient(follow_redirects=True) as client:\n            response = await client.get(url, headers=headers, timeout=timeout)\n            duration = time.time() - start_time\n            return StatusResult(\n                endpoint_name=\"\",  # Filled by caller\n                url=url,\n                status_code=response.status_code,\n                latency=round(duration, 3),\n            )\n    except httpx.TimeoutException:\n        return StatusResult(endpoint_name=\"\", url=url, error=\"Timeout\")\n    except Exception as e:\n        return StatusResult(endpoint_name=\"\", url=url, error=str(e))\n</code></pre>"},{"location":"#nscholia.version","title":"<code>version</code>","text":""},{"location":"#nscholia.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>Version handling for nicescholia</p> Source code in <code>nscholia/version.py</code> <pre><code>@dataclass\nclass Version:\n    \"\"\"\n    Version handling for nicescholia\n    \"\"\"\n\n    name = \"nicescholia\"\n    version = nscholia.__version__\n    date = \"2025-12-17\"\n    updated = \"2025-12-17\"\n    description = \"nicegui based scholia\"\n    authors = \"Wolfgang Fahl\"\n    doc_url = \"https://wiki.bitplan.com/index.php/nicescholia\"\n    chat_url = \"https://github.com/WolfgangFahl/nicescholia/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/nicescholia\"\n    license = \"\"\"Copyright 2025 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#nscholia.webserver","title":"<code>webserver</code>","text":"<p>Webserver definition</p>"},{"location":"#nscholia.webserver.ScholiaSolution","title":"<code>ScholiaSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>Handling specific page requests for a client session.</p> Source code in <code>nscholia/webserver.py</code> <pre><code>class ScholiaSolution(InputWebSolution):\n    \"\"\"\n    Handling specific page requests for a client session.\n    \"\"\"\n\n    def __init__(self, webserver, client: client):\n        super().__init__(webserver, client)\n\n    def setup_menu(self, detailed: bool = True):\n        \"\"\"\n        Configure the navigation menu\n        \"\"\"\n        # Call safe setup from parent\n        super().setup_menu(detailed=detailed)\n\n        # Add custom links\n        with self.header:\n            self.link_button(\"Dashboard\", \"/\", \"dashboard\")\n            # Example of external link\n            self.link_button(\n                \"GitHub\",\n                \"https://github.com/WolfgangFahl/nicescholia\",\n                \"code\",\n                new_tab=True,\n            )\n\n    async def home(self):\n        \"\"\"\n        The main page content\n        \"\"\"\n\n        def show():\n            # Instantiate the View Component\n            self.dashboard = Dashboard(self)\n            self.dashboard.setup_ui()\n\n        await self.setup_content_div(show)\n</code></pre>"},{"location":"#nscholia.webserver.ScholiaSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>The main page content</p> Source code in <code>nscholia/webserver.py</code> <pre><code>async def home(self):\n    \"\"\"\n    The main page content\n    \"\"\"\n\n    def show():\n        # Instantiate the View Component\n        self.dashboard = Dashboard(self)\n        self.dashboard.setup_ui()\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#nscholia.webserver.ScholiaSolution.setup_menu","title":"<code>setup_menu(detailed=True)</code>","text":"<p>Configure the navigation menu</p> Source code in <code>nscholia/webserver.py</code> <pre><code>def setup_menu(self, detailed: bool = True):\n    \"\"\"\n    Configure the navigation menu\n    \"\"\"\n    # Call safe setup from parent\n    super().setup_menu(detailed=detailed)\n\n    # Add custom links\n    with self.header:\n        self.link_button(\"Dashboard\", \"/\", \"dashboard\")\n        # Example of external link\n        self.link_button(\n            \"GitHub\",\n            \"https://github.com/WolfgangFahl/nicescholia\",\n            \"code\",\n            new_tab=True,\n        )\n</code></pre>"},{"location":"#nscholia.webserver.ScholiaWebserver","title":"<code>ScholiaWebserver</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>The main webserver class</p> Source code in <code>nscholia/webserver.py</code> <pre><code>class ScholiaWebserver(InputWebserver):\n    \"\"\"\n    The main webserver class\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        config = WebserverConfig(\n            short_name=\"nicescholia\",\n            timeout=6.0,\n            copy_right=\"(c) 2025 Wolfgang Fahl\",\n            version=Version(),\n            default_port=9000,\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = ScholiaSolution\n        return server_config\n\n    def __init__(self):\n        super().__init__(config=ScholiaWebserver.get_config())\n</code></pre>"}]}